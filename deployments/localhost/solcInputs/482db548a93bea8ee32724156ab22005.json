{
  "language": "Solidity",
  "sources": {
    "contracts/BondDepository.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"./types/NoteKeeper.sol\";\n\nimport \"./libraries/SafeERC20.sol\";\n\nimport \"./interfaces/IERC20Metadata.sol\";\nimport \"./interfaces/IBondDepository.sol\";\n\n/// @title Encountr Bond Depository\n\ncontract EncountrBondDepository is IBondDepository, NoteKeeper {\n    /* ======== DEPENDENCIES ======== */\n\n    using SafeERC20 for IERC20;\n\n    /* ======== EVENTS ======== */\n\n    event CreateMarket(uint256 indexed id, address indexed baseToken, address indexed quoteToken, uint256 initialPrice);\n    event CloseMarket(uint256 indexed id);\n    event Bond(uint256 indexed id, uint256 amount, uint256 price);\n    event Tuned(uint256 indexed id, uint64 oldControlVariable, uint64 newControlVariable);\n\n    /* ======== STATE VARIABLES ======== */\n\n    // Storage\n    Market[] public markets; // persistent market data\n    Terms[] public terms; // deposit construction data\n    Metadata[] public metadata; // extraneous market data\n    mapping(uint256 => Adjustment) public adjustments; // control variable changes\n\n    // Queries\n    mapping(address => uint256[]) public marketsForQuote; // market IDs for quote token\n\n    /* ======== CONSTRUCTOR ======== */\n\n    constructor(\n        IEncountrAuthority _authority,\n        IERC20 _encountr,\n        IgENCTR _gencountr,\n        IStaking _staking,\n        ITreasury _treasury\n    ) NoteKeeper(_authority, _encountr, _gencountr, _staking, _treasury) {\n        // save gas for users by bulk approving stake() transactions\n        _encountr.approve(address(_staking), 1e45);\n    }\n\n    /* ======== DEPOSIT ======== */\n\n    /**\n     * @notice             deposit quote tokens in exchange for a bond from a specified market\n     * @param _id          the ID of the market\n     * @param _amount      the amount of quote token to spend\n     * @param _maxPrice    the maximum price at which to buy\n     * @param _user        the recipient of the payout\n     * @param _referral    the front end operator address\n     * @return payout_     the amount of gENCTR due\n     * @return expiry_     the timestamp at which payout is redeemable\n     * @return index_      the user index of the Note (used to redeem or query information)\n     */\n    function deposit(\n        uint256 _id,\n        uint256 _amount,\n        uint256 _maxPrice,\n        address _user,\n        address _referral\n    )\n        external\n        override\n        returns (\n            uint256 payout_,\n            uint256 expiry_,\n            uint256 index_\n        )\n    {\n        Market storage market = markets[_id];\n        Terms memory term = terms[_id];\n        uint48 currentTime = uint48(block.timestamp);\n\n        // Markets end at a defined timestamp\n        // |-------------------------------------| t\n        require(currentTime < term.conclusion, \"Depository: market concluded\");\n\n        // Debt and the control variable decay over time\n        _decay(_id, currentTime);\n\n        // Users input a maximum price, which protects them from price changes after\n        // entering the mempool. max price is a slippage mitigation measure\n        uint256 price = _marketPrice(_id);\n        require(price <= _maxPrice, \"Depository: more than max price\");\n\n        /**\n         * payout for the deposit = amount / price\n         *\n         * where\n         * payout = ENCTR out\n         * amount = quote tokens in\n         * price = quote tokens : encountr (i.e. 42069 DAI : ENCTR)\n         *\n         * 1e18 = ENCTR decimals (9) + price decimals (9)\n         */\n        payout_ = ((_amount * 1e18) / price) / (10**metadata[_id].quoteDecimals);\n\n        // markets have a max payout amount, capping size because deposits\n        // do not experience slippage. max payout is recalculated upon tuning\n        require(payout_ <= market.maxPayout, \"Depository: max size exceeded\");\n\n        /*\n         * each market is initialized with a capacity\n         *\n         * this is either the number of ENCTR that the market can sell\n         * (if capacity in quote is false),\n         *\n         * or the number of quote tokens that the market can buy\n         * (if capacity in quote is true)\n         */\n        market.capacity -= market.capacityInQuote ? _amount : payout_;\n\n        /**\n         * bonds mature with a cliff at a set timestamp\n         * prior to the expiry timestamp, no payout tokens are accessible to the user\n         * after the expiry timestamp, the entire payout can be redeemed\n         *\n         * there are two types of bonds: fixed-term and fixed-expiration\n         *\n         * fixed-term bonds mature in a set amount of time from deposit\n         * i.e. term = 1 week. when alice deposits on day 1, her bond\n         * expires on day 8. when bob deposits on day 2, his bond expires day 9.\n         *\n         * fixed-expiration bonds mature at a set timestamp\n         * i.e. expiration = day 10. when alice deposits on day 1, her term\n         * is 9 days. when bob deposits on day 2, his term is 8 days.\n         */\n        expiry_ = term.fixedTerm ? term.vesting + currentTime : term.vesting;\n\n        // markets keep track of how many quote tokens have been\n        // purchased, and how much ENCTR has been sold\n        market.purchased += _amount;\n        market.sold += uint64(payout_);\n\n        // incrementing total debt raises the price of the next bond\n        market.totalDebt += uint64(payout_);\n\n        emit Bond(_id, _amount, price);\n\n        /**\n         * user data is stored as Notes. these are isolated array entries\n         * storing the amount due, the time created, the time when payout\n         * is redeemable, the time when payout was redeemed, and the ID\n         * of the market deposited into\n         */\n        index_ = addNote(_user, payout_, uint48(expiry_), uint48(_id), _referral);\n\n        // transfer payment to treasury\n        market.quoteToken.safeTransferFrom(msg.sender, address(treasury), _amount);\n\n        // if max debt is breached, the market is closed\n        // this a circuit breaker\n        if (term.maxDebt < market.totalDebt) {\n            market.capacity = 0;\n            emit CloseMarket(_id);\n        } else {\n            // if market will continue, the control variable is tuned to hit targets on time\n            _tune(_id, currentTime);\n        }\n    }\n\n    /**\n     * @notice             decay debt, and adjust control variable if there is an active change\n     * @param _id          ID of market\n     * @param _time        uint48 timestamp (saves gas when passed in)\n     */\n    function _decay(uint256 _id, uint48 _time) internal {\n        // Debt decay\n\n        /*\n         * Debt is a time-decayed sum of tokens spent in a market\n         * Debt is added when deposits occur and removed over time\n         * |\n         * |    debt falls with\n         * |   / \\  inactivity       / \\\n         * | /     \\              /\\/    \\\n         * |         \\           /         \\\n         * |           \\      /\\/            \\\n         * |             \\  /  and rises       \\\n         * |                with deposits\n         * |\n         * |------------------------------------| t\n         */\n        markets[_id].totalDebt -= debtDecay(_id);\n        metadata[_id].lastDecay = _time;\n\n        // Control variable decay\n\n        // The bond control variable is continually tuned. When it is lowered (which\n        // lowers the market price), the change is carried out smoothly over time.\n        if (adjustments[_id].active) {\n            Adjustment storage adjustment = adjustments[_id];\n\n            (uint64 adjustBy, uint48 secondsSince, bool stillActive) = _controlDecay(_id);\n            terms[_id].controlVariable -= adjustBy;\n\n            if (stillActive) {\n                adjustment.change -= adjustBy;\n                adjustment.timeToAdjusted -= secondsSince;\n                adjustment.lastAdjustment = _time;\n            } else {\n                adjustment.active = false;\n            }\n        }\n    }\n\n    /**\n     * @notice             auto-adjust control variable to hit capacity/spend target\n     * @param _id          ID of market\n     * @param _time        uint48 timestamp (saves gas when passed in)\n     */\n    function _tune(uint256 _id, uint48 _time) internal {\n        Metadata memory meta = metadata[_id];\n\n        if (_time >= meta.lastTune + meta.tuneInterval) {\n            Market memory market = markets[_id];\n\n            // compute seconds remaining until market will conclude\n            uint256 timeRemaining = terms[_id].conclusion - _time;\n            uint256 price = _marketPrice(_id);\n\n            // standardize capacity into an base token amount\n            // encountr decimals (9) + price decimals (9)\n            uint256 capacity = market.capacityInQuote\n                ? ((market.capacity * 1e18) / price) / (10**meta.quoteDecimals)\n                : market.capacity;\n\n            /**\n             * calculate the correct payout to complete on time assuming each bond\n             * will be max size in the desired deposit interval for the remaining time\n             *\n             * i.e. market has 10 days remaining. deposit interval is 1 day. capacity\n             * is 10,000 ENCTR. max payout would be 1,000 ENCTR (10,000 * 1 / 10).\n             */\n            markets[_id].maxPayout = uint64((capacity * meta.depositInterval) / timeRemaining);\n\n            // calculate the ideal total debt to satisfy capacity in the remaining time\n            uint256 targetDebt = (capacity * meta.length) / timeRemaining;\n\n            // derive a new control variable from the target debt and current supply\n            uint64 newControlVariable = uint64((price * treasury.baseSupply()) / targetDebt);\n\n            emit Tuned(_id, terms[_id].controlVariable, newControlVariable);\n\n            if (newControlVariable >= terms[_id].controlVariable) {\n                terms[_id].controlVariable = newControlVariable;\n            } else {\n                // if decrease, control variable change will be carried out over the tune interval\n                // this is because price will be lowered\n                uint64 change = terms[_id].controlVariable - newControlVariable;\n                adjustments[_id] = Adjustment(change, _time, meta.tuneInterval, true);\n            }\n            metadata[_id].lastTune = _time;\n        }\n    }\n\n    /* ======== CREATE ======== */\n\n    /**\n     * @notice             creates a new market type\n     * @dev                current price should be in 9 decimals.\n     * @param _quoteToken  token used to deposit\n     * @param _market      [capacity (in ENCTR or quote), initial price / ENCTR (9 decimals), debt buffer (3 decimals)]\n     * @param _booleans    [capacity in quote, fixed term]\n     * @param _terms       [vesting length (if fixed term) or vested timestamp, conclusion timestamp]\n     * @param _intervals   [deposit interval (seconds), tune interval (seconds)]\n     * @return id_         ID of new bond market\n     */\n    function create(\n        IERC20 _quoteToken,\n        uint256[3] memory _market,\n        bool[2] memory _booleans,\n        uint256[2] memory _terms,\n        uint32[2] memory _intervals\n    ) external override onlyPolicy returns (uint256 id_) {\n        // the length of the program, in seconds\n        uint256 secondsToConclusion = _terms[1] - block.timestamp;\n\n        // the decimal count of the quote token\n        uint256 decimals = IERC20Metadata(address(_quoteToken)).decimals();\n\n        /*\n         * initial target debt is equal to capacity (this is the amount of debt\n         * that will decay over in the length of the program if price remains the same).\n         * it is converted into base token terms if passed in in quote token terms.\n         *\n         * 1e18 = encountr decimals (9) + initial price decimals (9)\n         */\n        uint64 targetDebt = uint64(_booleans[0] ? ((_market[0] * 1e18) / _market[1]) / 10**decimals : _market[0]);\n\n        /*\n         * max payout is the amount of capacity that should be utilized in a deposit\n         * interval. for example, if capacity is 1,000 ENCTR, there are 10 days to conclusion,\n         * and the preferred deposit interval is 1 day, max payout would be 100 ENCTR.\n         */\n        uint64 maxPayout = uint64((targetDebt * _intervals[0]) / secondsToConclusion);\n\n        /*\n         * max debt serves as a circuit breaker for the market. let's say the quote\n         * token is a stablecoin, and that stablecoin depegs. without max debt, the\n         * market would continue to buy until it runs out of capacity. this is\n         * configurable with a 3 decimal buffer (1000 = 1% above initial price).\n         * note that its likely advisable to keep this buffer wide.\n         * note that the buffer is above 100%. i.e. 10% buffer = initial debt * 1.1\n         */\n        uint256 maxDebt = targetDebt + ((targetDebt * _market[2]) / 1e5); // 1e5 = 100,000. 10,000 / 100,000 = 10%.\n\n        /*\n         * the control variable is set so that initial price equals the desired\n         * initial price. the control variable is the ultimate determinant of price,\n         * so we compute this last.\n         *\n         * price = control variable * debt ratio\n         * debt ratio = total debt / supply\n         * therefore, control variable = price / debt ratio\n         */\n        uint256 controlVariable = (_market[1] * treasury.baseSupply()) / targetDebt;\n\n        // depositing into, or getting info for, the created market uses this ID\n        id_ = markets.length;\n\n        markets.push(\n            Market({\n                quoteToken: _quoteToken,\n                capacityInQuote: _booleans[0],\n                capacity: _market[0],\n                totalDebt: targetDebt,\n                maxPayout: maxPayout,\n                purchased: 0,\n                sold: 0\n            })\n        );\n\n        terms.push(\n            Terms({\n                fixedTerm: _booleans[1],\n                controlVariable: uint64(controlVariable),\n                vesting: uint48(_terms[0]),\n                conclusion: uint48(_terms[1]),\n                maxDebt: uint64(maxDebt)\n            })\n        );\n\n        metadata.push(\n            Metadata({\n                lastTune: uint48(block.timestamp),\n                lastDecay: uint48(block.timestamp),\n                length: uint48(secondsToConclusion),\n                depositInterval: _intervals[0],\n                tuneInterval: _intervals[1],\n                quoteDecimals: uint8(decimals)\n            })\n        );\n\n        marketsForQuote[address(_quoteToken)].push(id_);\n\n        emit CreateMarket(id_, address(encountr), address(_quoteToken), _market[1]);\n    }\n\n    /**\n     * @notice             disable existing market\n     * @param _id          ID of market to close\n     */\n    function close(uint256 _id) external override onlyPolicy {\n        terms[_id].conclusion = uint48(block.timestamp);\n        markets[_id].capacity = 0;\n        emit CloseMarket(_id);\n    }\n\n    /* ======== EXTERNAL VIEW ======== */\n\n    /**\n     * @notice             calculate current market price of quote token in base token\n     * @dev                accounts for debt and control variable decay since last deposit (vs _marketPrice())\n     * @param _id          ID of market\n     * @return             price for market in ENCTR decimals\n     *\n     * price is derived from the equation\n     *\n     * p = cv * dr\n     *\n     * where\n     * p = price\n     * cv = control variable\n     * dr = debt ratio\n     *\n     * dr = d / s\n     *\n     * where\n     * d = debt\n     * s = supply of token at market creation\n     *\n     * d -= ( d * (dt / l) )\n     *\n     * where\n     * dt = change in time\n     * l = length of program\n     */\n    function marketPrice(uint256 _id) public view override returns (uint256) {\n        return (currentControlVariable(_id) * debtRatio(_id)) / (10**metadata[_id].quoteDecimals);\n    }\n\n    /**\n     * @notice             payout due for amount of quote tokens\n     * @dev                accounts for debt and control variable decay so it is up to date\n     * @param _amount      amount of quote tokens to spend\n     * @param _id          ID of market\n     * @return             amount of ENCTR to be paid in ENCTR decimals\n     *\n     * @dev 1e18 = encountr decimals (9) + market price decimals (9)\n     */\n    function payoutFor(uint256 _amount, uint256 _id) external view override returns (uint256) {\n        Metadata memory meta = metadata[_id];\n        return (_amount * 1e18) / marketPrice(_id) / 10**meta.quoteDecimals;\n    }\n\n    /**\n     * @notice             calculate current ratio of debt to supply\n     * @dev                uses current debt, which accounts for debt decay since last deposit (vs _debtRatio())\n     * @param _id          ID of market\n     * @return             debt ratio for market in quote decimals\n     */\n    function debtRatio(uint256 _id) public view override returns (uint256) {\n        return (currentDebt(_id) * (10**metadata[_id].quoteDecimals)) / treasury.baseSupply();\n    }\n\n    /**\n     * @notice             calculate debt factoring in decay\n     * @dev                accounts for debt decay since last deposit\n     * @param _id          ID of market\n     * @return             current debt for market in ENCTR decimals\n     */\n    function currentDebt(uint256 _id) public view override returns (uint256) {\n        return markets[_id].totalDebt - debtDecay(_id);\n    }\n\n    /**\n     * @notice             amount of debt to decay from total debt for market ID\n     * @param _id          ID of market\n     * @return             amount of debt to decay\n     */\n    function debtDecay(uint256 _id) public view override returns (uint64) {\n        Metadata memory meta = metadata[_id];\n\n        uint256 secondsSince = block.timestamp - meta.lastDecay;\n\n        return uint64((markets[_id].totalDebt * secondsSince) / meta.length);\n    }\n\n    /**\n     * @notice             up to date control variable\n     * @dev                accounts for control variable adjustment\n     * @param _id          ID of market\n     * @return             control variable for market in ENCTR decimals\n     */\n    function currentControlVariable(uint256 _id) public view returns (uint256) {\n        (uint64 decay, , ) = _controlDecay(_id);\n        return terms[_id].controlVariable - decay;\n    }\n\n    /**\n     * @notice             is a given market accepting deposits\n     * @param _id          ID of market\n     */\n    function isLive(uint256 _id) public view override returns (bool) {\n        return (markets[_id].capacity != 0 && terms[_id].conclusion > block.timestamp);\n    }\n\n    /**\n     * @notice returns an array of all active market IDs\n     */\n    function liveMarkets() external view override returns (uint256[] memory) {\n        uint256 num;\n        for (uint256 i = 0; i < markets.length; i++) {\n            if (isLive(i)) num++;\n        }\n\n        uint256[] memory ids = new uint256[](num);\n        uint256 nonce;\n        for (uint256 i = 0; i < markets.length; i++) {\n            if (isLive(i)) {\n                ids[nonce] = i;\n                nonce++;\n            }\n        }\n        return ids;\n    }\n\n    /**\n     * @notice             returns an array of all active market IDs for a given quote token\n     * @param _token       quote token to check for\n     */\n    function liveMarketsFor(address _token) external view override returns (uint256[] memory) {\n        uint256[] memory mkts = marketsForQuote[_token];\n        uint256 num;\n\n        for (uint256 i = 0; i < mkts.length; i++) {\n            if (isLive(mkts[i])) num++;\n        }\n\n        uint256[] memory ids = new uint256[](num);\n        uint256 nonce;\n\n        for (uint256 i = 0; i < mkts.length; i++) {\n            if (isLive(mkts[i])) {\n                ids[nonce] = mkts[i];\n                nonce++;\n            }\n        }\n        return ids;\n    }\n\n    /* ======== INTERNAL VIEW ======== */\n\n    /**\n     * @notice                  calculate current market price of quote token in base token\n     * @dev                     see marketPrice() for explanation of price computation\n     * @dev                     uses info from storage because data has been updated before call (vs marketPrice())\n     * @param _id               market ID\n     * @return                  price for market in ENCTR decimals\n     */\n    function _marketPrice(uint256 _id) internal view returns (uint256) {\n        return (terms[_id].controlVariable * _debtRatio(_id)) / (10**metadata[_id].quoteDecimals);\n    }\n\n    /**\n     * @notice                  calculate debt factoring in decay\n     * @dev                     uses info from storage because data has been updated before call (vs debtRatio())\n     * @param _id               market ID\n     * @return                  current debt for market in quote decimals\n     */\n    function _debtRatio(uint256 _id) internal view returns (uint256) {\n        return (markets[_id].totalDebt * (10**metadata[_id].quoteDecimals)) / treasury.baseSupply();\n    }\n\n    /**\n     * @notice                  amount to decay control variable by\n     * @param _id               ID of market\n     * @return decay_           change in control variable\n     * @return secondsSince_    seconds since last change in control variable\n     * @return active_          whether or not change remains active\n     */\n    function _controlDecay(uint256 _id)\n        internal\n        view\n        returns (\n            uint64 decay_,\n            uint48 secondsSince_,\n            bool active_\n        )\n    {\n        Adjustment memory info = adjustments[_id];\n        if (!info.active) return (0, 0, false);\n\n        secondsSince_ = uint48(block.timestamp) - info.lastAdjustment;\n\n        active_ = secondsSince_ < info.timeToAdjusted;\n        decay_ = active_ ? (info.change * secondsSince_) / info.timeToAdjusted : info.change;\n    }\n}\n"
    },
    "contracts/types/NoteKeeper.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport \"../types/FrontEndRewarder.sol\";\n\nimport \"../interfaces/IgENCTR.sol\";\nimport \"../interfaces/IStaking.sol\";\nimport \"../interfaces/ITreasury.sol\";\nimport \"../interfaces/INoteKeeper.sol\";\n\nabstract contract NoteKeeper is INoteKeeper, FrontEndRewarder {\n    mapping(address => Note[]) public notes; // user deposit data\n    mapping(address => mapping(uint256 => address)) private noteTransfers; // change note ownership\n\n    IgENCTR internal immutable gENCTR;\n    IStaking internal immutable staking;\n    ITreasury internal treasury;\n\n    constructor(\n        IEncountrAuthority _authority,\n        IERC20 _encountr,\n        IgENCTR _gencountr,\n        IStaking _staking,\n        ITreasury _treasury\n    ) FrontEndRewarder(_authority, _encountr) {\n        gENCTR = _gencountr;\n        staking = _staking;\n        treasury = _treasury;\n    }\n\n    // if treasury address changes on authority, update it\n    function updateTreasury() external {\n        require(\n            msg.sender == authority.governor() ||\n                msg.sender == authority.guardian() ||\n                msg.sender == authority.policy(),\n            \"Only authorized\"\n        );\n        treasury = ITreasury(authority.vault());\n    }\n\n    /* ========== ADD ========== */\n\n    /**\n     * @notice             adds a new Note for a user, stores the front end & DAO rewards, and mints & stakes payout & rewards\n     * @param _user        the user that owns the Note\n     * @param _payout      the amount of ENCTR due to the user\n     * @param _expiry      the timestamp when the Note is redeemable\n     * @param _marketID    the ID of the market deposited into\n     * @return index_      the index of the Note in the user's array\n     */\n    function addNote(\n        address _user,\n        uint256 _payout,\n        uint48 _expiry,\n        uint48 _marketID,\n        address _referral\n    ) internal returns (uint256 index_) {\n        // the index of the note is the next in the user's array\n        index_ = notes[_user].length;\n\n        // the new note is pushed to the user's array\n        notes[_user].push(\n            Note({\n                payout: gENCTR.balanceTo(_payout),\n                created: uint48(block.timestamp),\n                matured: _expiry,\n                redeemed: 0,\n                marketID: _marketID\n            })\n        );\n\n        // front end operators can earn rewards by referring users\n        uint256 rewards = _giveRewards(_payout, _referral);\n\n        // mint and stake payout\n        treasury.mint(address(this), _payout + rewards);\n\n        // note that only the payout gets staked (front end rewards are in ENCTR)\n        staking.stake(address(this), _payout, false, true);\n    }\n\n    /* ========== REDEEM ========== */\n\n    /**\n     * @notice             redeem notes for user\n     * @param _user        the user to redeem for\n     * @param _indexes     the note indexes to redeem\n     * @param _sendgENCTR    send payout as gENCTR or sENCTR\n     * @return payout_     sum of payout sent, in gENCTR\n     */\n    function redeem(\n        address _user,\n        uint256[] memory _indexes,\n        bool _sendgENCTR\n    ) public override returns (uint256 payout_) {\n        uint48 time = uint48(block.timestamp);\n\n        for (uint256 i = 0; i < _indexes.length; i++) {\n            (uint256 pay, bool matured) = pendingFor(_user, _indexes[i]);\n\n            if (matured) {\n                notes[_user][_indexes[i]].redeemed = time; // mark as redeemed\n                payout_ += pay;\n            }\n        }\n\n        if (_sendgENCTR) {\n            gENCTR.transfer(_user, payout_); // send payout as gENCTR\n        } else {\n            staking.unwrap(_user, payout_); // unwrap and send payout as sENCTR\n        }\n    }\n\n    /**\n     * @notice             redeem all redeemable markets for user\n     * @dev                if possible, query indexesFor() off-chain and input in redeem() to save gas\n     * @param _user        user to redeem all notes for\n     * @param _sendgENCTR    send payout as gENCTR or sENCTR\n     * @return             sum of payout sent, in gENCTR\n     */\n    function redeemAll(address _user, bool _sendgENCTR) external override returns (uint256) {\n        return redeem(_user, indexesFor(_user), _sendgENCTR);\n    }\n\n    /* ========== TRANSFER ========== */\n\n    /**\n     * @notice             approve an address to transfer a note\n     * @param _to          address to approve note transfer for\n     * @param _index       index of note to approve transfer for\n     */\n    function pushNote(address _to, uint256 _index) external override {\n        require(notes[msg.sender][_index].created != 0, \"Depository: note not found\");\n        noteTransfers[msg.sender][_index] = _to;\n    }\n\n    /**\n     * @notice             transfer a note that has been approved by an address\n     * @param _from        the address that approved the note transfer\n     * @param _index       the index of the note to transfer (in the sender's array)\n     */\n    function pullNote(address _from, uint256 _index) external override returns (uint256 newIndex_) {\n        require(noteTransfers[_from][_index] == msg.sender, \"Depository: transfer not found\");\n        require(notes[_from][_index].redeemed == 0, \"Depository: note redeemed\");\n\n        newIndex_ = notes[msg.sender].length;\n        notes[msg.sender].push(notes[_from][_index]);\n\n        delete notes[_from][_index];\n    }\n\n    /* ========== VIEW ========== */\n\n    // Note info\n\n    /**\n     * @notice             all pending notes for user\n     * @param _user        the user to query notes for\n     * @return             the pending notes for the user\n     */\n    function indexesFor(address _user) public view override returns (uint256[] memory) {\n        Note[] memory info = notes[_user];\n\n        uint256 length;\n        for (uint256 i = 0; i < info.length; i++) {\n            if (info[i].redeemed == 0 && info[i].payout != 0) length++;\n        }\n\n        uint256[] memory indexes = new uint256[](length);\n        uint256 position;\n\n        for (uint256 i = 0; i < info.length; i++) {\n            if (info[i].redeemed == 0 && info[i].payout != 0) {\n                indexes[position] = i;\n                position++;\n            }\n        }\n\n        return indexes;\n    }\n\n    /**\n     * @notice             calculate amount available for claim for a single note\n     * @param _user        the user that the note belongs to\n     * @param _index       the index of the note in the user's array\n     * @return payout_     the payout due, in gENCTR\n     * @return matured_    if the payout can be redeemed\n     */\n    function pendingFor(address _user, uint256 _index) public view override returns (uint256 payout_, bool matured_) {\n        Note memory note = notes[_user][_index];\n\n        payout_ = note.payout;\n        matured_ = note.redeemed == 0 && note.matured <= block.timestamp && note.payout != 0;\n    }\n}\n"
    },
    "contracts/libraries/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.7.5;\n\nimport {IERC20} from \"../interfaces/IERC20.sol\";\n\n/// @notice Safe IERC20 and ETH transfer library that safely handles missing return values.\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/TransferHelper.sol)\n/// Taken from Solmate\nlibrary SafeERC20 {\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amount)\n        );\n\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(IERC20.transfer.selector, to, amount)\n        );\n\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(IERC20.approve.selector, to, amount)\n        );\n\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"APPROVE_FAILED\");\n    }\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        (bool success, ) = to.call{value: amount}(new bytes(0));\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n}\n"
    },
    "contracts/interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./IERC20.sol\";\n\ninterface IERC20Metadata is IERC20 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/IBondDepository.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./IERC20.sol\";\n\ninterface IBondDepository {\n    // Info about each type of market\n    struct Market {\n        uint256 capacity; // capacity remaining\n        IERC20 quoteToken; // token to accept as payment\n        bool capacityInQuote; // capacity limit is in payment token (true) or in ENCTR (false, default)\n        uint64 totalDebt; // total debt from market\n        uint64 maxPayout; // max tokens in/out (determined by capacityInQuote false/true, respectively)\n        uint64 sold; // base tokens out\n        uint256 purchased; // quote tokens in\n    }\n\n    // Info for creating new markets\n    struct Terms {\n        bool fixedTerm; // fixed term or fixed expiration\n        uint64 controlVariable; // scaling variable for price\n        uint48 vesting; // length of time from deposit to maturity if fixed-term\n        uint48 conclusion; // timestamp when market no longer offered (doubles as time when market matures if fixed-expiry)\n        uint64 maxDebt; // 9 decimal debt maximum in ENCTR\n    }\n\n    // Additional info about market.\n    struct Metadata {\n        uint48 lastTune; // last timestamp when control variable was tuned\n        uint48 lastDecay; // last timestamp when market was created and debt was decayed\n        uint48 length; // time from creation to conclusion. used as speed to decay debt.\n        uint48 depositInterval; // target frequency of deposits\n        uint48 tuneInterval; // frequency of tuning\n        uint8 quoteDecimals; // decimals of quote token\n    }\n\n    // Control variable adjustment data\n    struct Adjustment {\n        uint64 change;\n        uint48 lastAdjustment;\n        uint48 timeToAdjusted;\n        bool active;\n    }\n\n    /**\n     * @notice deposit market\n     * @param _bid uint256\n     * @param _amount uint256\n     * @param _maxPrice uint256\n     * @param _user address\n     * @param _referral address\n     * @return payout_ uint256\n     * @return expiry_ uint256\n     * @return index_ uint256\n     */\n    function deposit(\n        uint256 _bid,\n        uint256 _amount,\n        uint256 _maxPrice,\n        address _user,\n        address _referral\n    )\n        external\n        returns (\n            uint256 payout_,\n            uint256 expiry_,\n            uint256 index_\n        );\n\n    function create(\n        IERC20 _quoteToken, // token used to deposit\n        uint256[3] memory _market, // [capacity, initial price]\n        bool[2] memory _booleans, // [capacity in quote, fixed term]\n        uint256[2] memory _terms, // [vesting, conclusion]\n        uint32[2] memory _intervals // [deposit interval, tune interval]\n    ) external returns (uint256 id_);\n\n    function close(uint256 _id) external;\n\n    function isLive(uint256 _bid) external view returns (bool);\n\n    function liveMarkets() external view returns (uint256[] memory);\n\n    function liveMarketsFor(address _quoteToken) external view returns (uint256[] memory);\n\n    function payoutFor(uint256 _amount, uint256 _bid) external view returns (uint256);\n\n    function marketPrice(uint256 _bid) external view returns (uint256);\n\n    function currentDebt(uint256 _bid) external view returns (uint256);\n\n    function debtRatio(uint256 _bid) external view returns (uint256);\n\n    function debtDecay(uint256 _bid) external view returns (uint64);\n}\n"
    },
    "contracts/types/FrontEndRewarder.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport \"../types/EncountrAccessControlled.sol\";\nimport \"../interfaces/IERC20.sol\";\n\nabstract contract FrontEndRewarder is EncountrAccessControlled {\n    /* ========= STATE VARIABLES ========== */\n\n    uint256 public daoReward; // % reward for dao (3 decimals: 100 = 1%)\n    uint256 public refReward; // % reward for referrer (3 decimals: 100 = 1%)\n    mapping(address => uint256) public rewards; // front end operator rewards\n    mapping(address => bool) public whitelisted; // whitelisted status for operators\n\n    IERC20 internal immutable encountr; // reward token\n\n    constructor(IEncountrAuthority _authority, IERC20 _encountr) EncountrAccessControlled(_authority) {\n        encountr = _encountr;\n    }\n\n    /* ========= EXTERNAL FUNCTIONS ========== */\n\n    // pay reward to front end operator\n    function getReward() external {\n        uint256 reward = rewards[msg.sender];\n\n        rewards[msg.sender] = 0;\n        encountr.transfer(msg.sender, reward);\n    }\n\n    /* ========= INTERNAL ========== */\n\n    /**\n     * @notice add new market payout to user data\n     */\n    function _giveRewards(uint256 _payout, address _referral) internal returns (uint256) {\n        // first we calculate rewards paid to the DAO and to the front end operator (referrer)\n        uint256 toDAO = (_payout * daoReward) / 1e4;\n        uint256 toRef = (_payout * refReward) / 1e4;\n\n        // and store them in our rewards mapping\n        if (whitelisted[_referral]) {\n            rewards[_referral] += toRef;\n            rewards[authority.guardian()] += toDAO;\n        } else {\n            // the DAO receives both rewards if referrer is not whitelisted\n            rewards[authority.guardian()] += toDAO + toRef;\n        }\n        return toDAO + toRef;\n    }\n\n    /**\n     * @notice set rewards for front end operators and DAO\n     */\n    function setRewards(uint256 _toFrontEnd, uint256 _toDAO) external onlyGovernor {\n        refReward = _toFrontEnd;\n        daoReward = _toDAO;\n    }\n\n    /**\n     * @notice add or remove addresses from the reward whitelist\n     */\n    function whitelist(address _operator) external onlyPolicy {\n        whitelisted[_operator] = !whitelisted[_operator];\n    }\n}\n"
    },
    "contracts/interfaces/IgENCTR.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./IERC20.sol\";\n\ninterface IgENCTR is IERC20 {\n    function mint(address _to, uint256 _amount) external;\n\n    function burn(address _from, uint256 _amount) external;\n\n    function index() external view returns (uint256);\n\n    function balanceFrom(uint256 _amount) external view returns (uint256);\n\n    function balanceTo(uint256 _amount) external view returns (uint256);\n\n    function initialize(address _staking) external;\n}\n"
    },
    "contracts/interfaces/IStaking.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\ninterface IStaking {\n    function stake(\n        address _to,\n        uint256 _amount,\n        bool _rebasing,\n        bool _claim\n    ) external returns (uint256);\n\n    function claim(address _recipient, bool _rebasing) external returns (uint256);\n\n    function forfeit() external returns (uint256);\n\n    function toggleLock() external;\n\n    function unstake(\n        address _to,\n        uint256 _amount,\n        bool _trigger,\n        bool _rebasing\n    ) external returns (uint256);\n\n    function wrap(address _to, uint256 _amount) external returns (uint256 gBalance_);\n\n    function unwrap(address _to, uint256 _amount) external returns (uint256 sBalance_);\n\n    function rebase() external;\n\n    function index() external view returns (uint256);\n\n    function contractBalance() external view returns (uint256);\n\n    function totalStaked() external view returns (uint256);\n\n    function supplyInWarmup() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ITreasury.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\ninterface ITreasury {\n    function deposit(\n        uint256 _amount,\n        address _token,\n        uint256 _profit\n    ) external returns (uint256);\n\n    function withdraw(uint256 _amount, address _token) external;\n\n    function tokenValue(address _token, uint256 _amount) external view returns (uint256 value_);\n\n    function mint(address _recipient, uint256 _amount) external;\n\n    function manage(address _token, uint256 _amount) external;\n\n    function incurDebt(uint256 amount_, address token_) external;\n\n    function repayDebtWithReserve(uint256 amount_, address token_) external;\n\n    function excessReserves() external view returns (uint256);\n\n    function baseSupply() external view returns (uint256);\n\n    function isPermitted(uint _status, address _address) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/INoteKeeper.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.7.5;\n\ninterface INoteKeeper {\n    // Info for market note\n    struct Note {\n        uint256 payout; // gENCTR remaining to be paid\n        uint48 created; // time market was created\n        uint48 matured; // timestamp when market is matured\n        uint48 redeemed; // time market was redeemed\n        uint48 marketID; // market ID of deposit. uint48 to avoid adding a slot.\n    }\n\n    function redeem(\n        address _user,\n        uint256[] memory _indexes,\n        bool _sendgENCTR\n    ) external returns (uint256);\n\n    function redeemAll(address _user, bool _sendgENCTR) external returns (uint256);\n\n    function pushNote(address to, uint256 index) external;\n\n    function pullNote(address from, uint256 index) external returns (uint256 newIndex_);\n\n    function indexesFor(address _user) external view returns (uint256[] memory);\n\n    function pendingFor(address _user, uint256 _index) external view returns (uint256 payout_, bool matured_);\n}\n"
    },
    "contracts/types/EncountrAccessControlled.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.7.5;\n\nimport \"../interfaces/IEncountrAuthority.sol\";\n\nabstract contract EncountrAccessControlled {\n    /* ========== EVENTS ========== */\n\n    event AuthorityUpdated(IEncountrAuthority indexed authority);\n\n    string UNAUTHORIZED = \"UNAUTHORIZED\"; // save gas\n\n    /* ========== STATE VARIABLES ========== */\n\n    IEncountrAuthority public authority;\n\n    /* ========== Constructor ========== */\n\n    constructor(IEncountrAuthority _authority) {\n        authority = _authority;\n        emit AuthorityUpdated(_authority);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyGovernor() {\n        require(msg.sender == authority.governor(), UNAUTHORIZED);\n        _;\n    }\n\n    modifier onlyGuardian() {\n        require(msg.sender == authority.guardian(), UNAUTHORIZED);\n        _;\n    }\n\n    modifier onlyPolicy() {\n        require(msg.sender == authority.policy(), UNAUTHORIZED);\n        _;\n    }\n\n    modifier onlyVault() {\n        require(msg.sender == authority.vault(), UNAUTHORIZED);\n        _;\n    }\n\n    /* ========== GOV ONLY ========== */\n\n    function setAuthority(IEncountrAuthority _newAuthority) external onlyGovernor {\n        authority = _newAuthority;\n        emit AuthorityUpdated(_newAuthority);\n    }\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interfaces/IEncountrAuthority.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\ninterface IEncountrAuthority {\n    /* ========== EVENTS ========== */\n\n    event GovernorPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n    event GuardianPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n    event PolicyPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n    event VaultPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n\n    event GovernorPulled(address indexed from, address indexed to);\n    event GuardianPulled(address indexed from, address indexed to);\n    event PolicyPulled(address indexed from, address indexed to);\n    event VaultPulled(address indexed from, address indexed to);\n\n    /* ========== VIEW ========== */\n\n    function governor() external view returns (address);\n\n    function guardian() external view returns (address);\n\n    function policy() external view returns (address);\n\n    function vault() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IDistributor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\ninterface IDistributor {\n    function distribute() external;\n\n    function bounty() external view returns (uint256);\n\n    function retrieveBounty() external returns (uint256);\n\n    function nextRewardAt(uint256 _rate) external view returns (uint256);\n\n    function nextRewardFor(address _recipient) external view returns (uint256);\n\n    function setBounty(uint256 _bounty) external;\n\n    function addRecipient(address _recipient, uint256 _rewardRate) external;\n\n    function removeRecipient(uint256 _index) external;\n\n    function setAdjustment(\n        uint256 _index,\n        bool _add,\n        uint256 _rate,\n        uint256 _target\n    ) external;\n}\n"
    },
    "contracts/interfaces/IpENCTR.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./IERC20.sol\";\n\ninterface IpENCTR is IERC20 {\n    function isApprovedSeller(address account_) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IENCTR.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./IERC20.sol\";\n\ninterface IENCTR is IERC20 {\n    function mint(address account_, uint256 amount_) external;\n\n    function burn(uint256 amount) external;\n\n    function burnFrom(address account_, uint256 amount_) external;\n}\n"
    },
    "contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./IUniswapV2ERC20.sol\";\n\ninterface IUniswapV2Pair is IUniswapV2ERC20 {\n    function token0() external pure returns (address);\n\n    function token1() external pure returns (address);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function sync() external;\n}\n"
    },
    "contracts/interfaces/IUniswapV2ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\ninterface IUniswapV2ERC20 {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/interfaces/IBondingCalculator.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\ninterface IBondingCalculator {\n    function markdown(address _LP) external view returns (uint256);\n\n    function valuation(address pair_, uint256 amount_) external view returns (uint256 _value);\n}\n"
    },
    "contracts/peripheral/YieldDirector.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {IsENCTR} from \"../interfaces/IsENCTR.sol\";\nimport {SafeERC20} from \"../libraries/SafeERC20.sol\";\nimport {IYieldDirector} from \"../interfaces/IYieldDirector.sol\";\nimport {EncountrAccessControlled, IEncountrAuthority} from \"../types/EncountrAccessControlled.sol\";\n\n/**\n    @title YieldDirector (codename Tyche) \n    @notice This contract allows donors to deposit their sENCTR and donate their rebases\n            to any address. Donors will be able to withdraw their principal\n            sENCTR at any time. Donation recipients can also redeem accrued rebases at any time.\n */\ncontract YieldDirector is IYieldDirector, EncountrAccessControlled {\n    using SafeERC20 for IERC20;\n\n    uint256 private constant MAX_UINT256 = type(uint256).max;\n\n    address public immutable sENCTR;\n\n    bool public depositDisabled;\n    bool public withdrawDisabled;\n    bool public redeemDisabled;\n\n    struct DonationInfo {\n        address recipient;\n        uint256 deposit; // Total non-agnostic amount deposited\n        uint256 agnosticDeposit; // Total agnostic amount deposited\n        uint256 carry; // Amount of sENCTR accumulated over on deposit/withdraw\n        uint256 indexAtLastChange; // Index of last deposit/withdraw\n    }\n\n    struct RecipientInfo {\n        uint256 totalDebt; // Non-agnostic debt\n        uint256 carry; // Total non-agnostic value donating to recipient\n        uint256 agnosticDebt; // Total agnostic value of carry + debt\n        uint256 indexAtLastChange; // Index when agnostic value changed\n    }\n\n    mapping(address => DonationInfo[]) public donationInfo;\n    mapping(address => RecipientInfo) public recipientInfo;\n\n    event Deposited(address indexed donor_, address indexed recipient_, uint256 amount_);\n    event Withdrawn(address indexed donor_, address indexed recipient_, uint256 amount_);\n    event AllWithdrawn(address indexed donor_, uint256 indexed amount_);\n    event Donated(address indexed donor_, address indexed recipient_, uint256 amount_);\n    event Redeemed(address indexed recipient_, uint256 amount_);\n    event EmergencyShutdown(bool active_);\n\n    constructor(address sEnctr_, address authority_) EncountrAccessControlled(IEncountrAuthority(authority_)) {\n        require(sEnctr_ != address(0), \"Invalid address for sENCTR\");\n\n        sENCTR = sEnctr_;\n    }\n\n    /************************\n     * Donor Functions\n     ************************/\n\n    /**\n        @notice Deposit sENCTR, records sender address and assign rebases to recipient\n        @param amount_ Amount of sENCTR debt issued from donor to recipient\n        @param recipient_ Address to direct staking yield and vault shares to\n    */\n    function deposit(uint256 amount_, address recipient_) external override {\n        require(!depositDisabled, \"Deposits currently disabled\");\n        require(amount_ > 0, \"Invalid deposit amount\");\n        require(recipient_ != address(0), \"Invalid recipient address\");\n\n        IERC20(sENCTR).safeTransferFrom(msg.sender, address(this), amount_);\n\n        uint256 index = IsENCTR(sENCTR).index();\n\n        // Record donors's issued debt to recipient address\n        DonationInfo[] storage donations = donationInfo[msg.sender];\n        uint256 recipientIndex = _getRecipientIndex(msg.sender, recipient_);\n\n        if (recipientIndex == MAX_UINT256) {\n            donations.push(\n                DonationInfo({\n                    recipient: recipient_,\n                    deposit: amount_,\n                    agnosticDeposit: _toAgnostic(amount_),\n                    carry: 0,\n                    indexAtLastChange: index\n                })\n            );\n        } else {\n            DonationInfo storage donation = donations[recipientIndex];\n\n            donation.carry += _getAccumulatedValue(donation.agnosticDeposit, donation.indexAtLastChange);\n            donation.deposit += amount_;\n            donation.agnosticDeposit = _toAgnostic(donation.deposit);\n            donation.indexAtLastChange = index;\n        }\n\n        RecipientInfo storage recipient = recipientInfo[recipient_];\n\n        // Calculate value carried over since last change\n        recipient.carry += _getAccumulatedValue(recipient.agnosticDebt, recipient.indexAtLastChange);\n        recipient.totalDebt += amount_;\n        recipient.agnosticDebt = _toAgnostic(recipient.totalDebt + recipient.carry);\n        recipient.indexAtLastChange = index;\n\n        emit Deposited(msg.sender, recipient_, amount_);\n    }\n\n    /**\n        @notice Withdraw donor's sENCTR from vault and subtracts debt from recipient\n     */\n    function withdraw(uint256 amount_, address recipient_) external override {\n        require(!withdrawDisabled, \"Withdraws currently disabled\");\n        require(amount_ > 0, \"Invalid withdraw amount\");\n\n        uint256 index = IsENCTR(sENCTR).index();\n\n        // Donor accounting\n        uint256 recipientIndex = _getRecipientIndex(msg.sender, recipient_);\n        require(recipientIndex != MAX_UINT256, \"No donations to recipient\");\n\n        DonationInfo storage donation = donationInfo[msg.sender][recipientIndex];\n\n        if (amount_ >= donation.deposit) {\n            // Report how much was donated then clear donation information\n            uint256 accumulated = donation.carry +\n                _getAccumulatedValue(donation.agnosticDeposit, donation.indexAtLastChange);\n            emit Donated(msg.sender, recipient_, accumulated);\n\n            delete donationInfo[msg.sender][recipientIndex];\n\n            // If element was in middle of array, bring last element to deleted index\n            uint256 lastIndex = donationInfo[msg.sender].length - 1;\n            if (recipientIndex != lastIndex) {\n                donationInfo[msg.sender][recipientIndex] = donationInfo[msg.sender][lastIndex];\n                donationInfo[msg.sender].pop();\n            }\n        } else {\n            donation.carry += _getAccumulatedValue(donation.agnosticDeposit, donation.indexAtLastChange);\n            donation.deposit -= amount_;\n            donation.agnosticDeposit = _toAgnostic(donation.deposit);\n            donation.indexAtLastChange = index;\n        }\n\n        // Recipient accounting\n        RecipientInfo storage recipient = recipientInfo[recipient_];\n        recipient.carry += _getAccumulatedValue(recipient.agnosticDebt, recipient.indexAtLastChange);\n        recipient.totalDebt -= amount_;\n        recipient.agnosticDebt = _toAgnostic(recipient.totalDebt + recipient.carry);\n        recipient.indexAtLastChange = index;\n\n        IERC20(sENCTR).safeTransfer(msg.sender, amount_);\n\n        emit Withdrawn(msg.sender, recipient_, amount_);\n    }\n\n    /**\n        @notice Withdraw from all donor positions\n     */\n    function withdrawAll() external override {\n        require(!withdrawDisabled, \"Withdraws currently disabled\");\n\n        DonationInfo[] storage donations = donationInfo[msg.sender];\n\n        uint256 donationsLength = donations.length;\n        require(donationsLength != 0, \"User not donating to anything\");\n\n        uint256 sEnctrIndex = IsENCTR(sENCTR).index();\n        uint256 total = 0;\n\n        for (uint256 index = 0; index < donationsLength; index++) {\n            DonationInfo storage donation = donations[index];\n\n            total += donation.deposit;\n\n            RecipientInfo storage recipient = recipientInfo[donation.recipient];\n            recipient.carry += _getAccumulatedValue(recipient.agnosticDebt, recipient.indexAtLastChange);\n            recipient.totalDebt -= donation.deposit;\n            recipient.agnosticDebt = _toAgnostic(recipient.totalDebt + recipient.carry);\n            recipient.indexAtLastChange = sEnctrIndex;\n\n            // Report amount donated\n            uint256 accumulated = donation.carry +\n                _getAccumulatedValue(donation.agnosticDeposit, donation.indexAtLastChange);\n            emit Donated(msg.sender, donation.recipient, accumulated);\n        }\n\n        // Delete donor's entire donations array\n        delete donationInfo[msg.sender];\n\n        IERC20(sENCTR).safeTransfer(msg.sender, total);\n\n        emit AllWithdrawn(msg.sender, total);\n    }\n\n    /**\n        @notice Get deposited sENCTR amount for specific recipient\n     */\n    function depositsTo(address donor_, address recipient_) external view override returns (uint256) {\n        uint256 recipientIndex = _getRecipientIndex(donor_, recipient_);\n        require(recipientIndex != MAX_UINT256, \"No deposits\");\n\n        return donationInfo[donor_][recipientIndex].deposit;\n    }\n\n    /**\n        @notice Return total amount of donor's sENCTR deposited\n     */\n    function totalDeposits(address donor_) external view override returns (uint256) {\n        DonationInfo[] storage donations = donationInfo[donor_];\n        require(donations.length != 0, \"User is not donating\");\n\n        uint256 total = 0;\n        for (uint256 index = 0; index < donations.length; index++) {\n            total += donations[index].deposit;\n        }\n\n        return total;\n    }\n\n    /**\n        @notice Return arrays of donor's recipients and deposit amounts, matched by index\n     */\n    function getAllDeposits(address donor_) external view override returns (address[] memory, uint256[] memory) {\n        DonationInfo[] storage donations = donationInfo[donor_];\n        require(donations.length != 0, \"User is not donating\");\n\n        uint256 len = donations.length;\n\n        address[] memory addresses = new address[](len);\n        uint256[] memory deposits = new uint256[](len);\n\n        for (uint256 index = 0; index < len; index++) {\n            addresses[index] = donations[index].recipient;\n            deposits[index] = donations[index].deposit;\n        }\n\n        return (addresses, deposits);\n    }\n\n    /**\n        @notice Return total amount of sENCTR donated to recipient since last full withdrawal\n     */\n    function donatedTo(address donor_, address recipient_) external view override returns (uint256) {\n        uint256 recipientIndex = _getRecipientIndex(donor_, recipient_);\n        require(recipientIndex != MAX_UINT256, \"No donations to recipient\");\n\n        DonationInfo storage donation = donationInfo[donor_][recipientIndex];\n        return donation.carry + _getAccumulatedValue(donation.agnosticDeposit, donation.indexAtLastChange);\n    }\n\n    /**\n        @notice Return total amount of sENCTR donated from donor since last full withdrawal\n     */\n    function totalDonated(address donor_) external view override returns (uint256) {\n        DonationInfo[] storage donations = donationInfo[donor_];\n        uint256 total = 0;\n\n        for (uint256 index = 0; index < donations.length; index++) {\n            DonationInfo storage donation = donations[index];\n            total += donation.carry + _getAccumulatedValue(donation.agnosticDeposit, donation.indexAtLastChange);\n        }\n\n        return total;\n    }\n\n    /************************\n     * Recipient Functions\n     ************************/\n\n    /**\n        @notice Get redeemable sENCTR balance of a recipient address\n     */\n    function redeemableBalance(address recipient_) public view override returns (uint256) {\n        RecipientInfo storage recipient = recipientInfo[recipient_];\n        return recipient.carry + _getAccumulatedValue(recipient.agnosticDebt, recipient.indexAtLastChange);\n    }\n\n    /**\n        @notice Redeem recipient's full donated amount of sENCTR at current index\n        @dev Note that a recipient redeeming their vault shares effectively pays back all\n             sENCTR debt to donors at the time of redeem. Any future incurred debt will\n             be accounted for with a subsequent redeem or a withdrawal by the specific donor.\n     */\n    function redeem() external override {\n        require(!redeemDisabled, \"Redeems currently disabled\");\n\n        uint256 redeemable = redeemableBalance(msg.sender);\n        require(redeemable > 0, \"No redeemable balance\");\n\n        RecipientInfo storage recipient = recipientInfo[msg.sender];\n        recipient.agnosticDebt = _toAgnostic(recipient.totalDebt);\n        recipient.carry = 0;\n        recipient.indexAtLastChange = IsENCTR(sENCTR).index();\n\n        IERC20(sENCTR).safeTransfer(msg.sender, redeemable);\n\n        emit Redeemed(msg.sender, redeemable);\n    }\n\n    /************************\n     * Utility Functions\n     ************************/\n\n    /**\n        @notice Get accumulated sENCTR since last time agnostic value changed.\n     */\n    function _getAccumulatedValue(uint256 gAmount_, uint256 indexAtLastChange_) internal view returns (uint256) {\n        return _fromAgnostic(gAmount_) - _fromAgnosticAtIndex(gAmount_, indexAtLastChange_);\n    }\n\n    /**\n        @notice Get array index of a particular recipient in a donor's donationInfo array.\n        @return Array index of recipient address. If recipient not present, returns max uint256 value.\n     */\n    function _getRecipientIndex(address donor_, address recipient_) internal view returns (uint256) {\n        DonationInfo[] storage info = donationInfo[donor_];\n\n        uint256 existingIndex = MAX_UINT256;\n        for (uint256 i = 0; i < info.length; i++) {\n            if (info[i].recipient == recipient_) {\n                existingIndex = i;\n                break;\n            }\n        }\n        return existingIndex;\n    }\n\n    /**\n        @notice Convert flat sENCTR value to agnostic value at current index\n        @dev Agnostic value earns rebases. Agnostic value is amount / rebase_index.\n             1e9 is because sENCTR has 9 decimals.\n     */\n    function _toAgnostic(uint256 amount_) internal view returns (uint256) {\n        return (amount_ * 1e9) / (IsENCTR(sENCTR).index());\n    }\n\n    /**\n        @notice Convert agnostic value at current index to flat sENCTR value\n        @dev Agnostic value earns rebases. Agnostic value is amount / rebase_index.\n             1e9 is because sENCTR has 9 decimals.\n     */\n    function _fromAgnostic(uint256 amount_) internal view returns (uint256) {\n        return (amount_ * (IsENCTR(sENCTR).index())) / 1e9;\n    }\n\n    /**\n        @notice Convert flat sENCTR value to agnostic value at a given index value\n        @dev Agnostic value earns rebases. Agnostic value is amount / rebase_index.\n             1e9 is because sENCTR has 9 decimals.\n     */\n    function _fromAgnosticAtIndex(uint256 amount_, uint256 index_) internal pure returns (uint256) {\n        return (amount_ * index_) / 1e9;\n    }\n\n    /************************\n     * Emergency Functions\n     ************************/\n\n    function emergencyShutdown(bool active_) external onlyGovernor {\n        depositDisabled = active_;\n        withdrawDisabled = active_;\n        redeemDisabled = active_;\n        emit EmergencyShutdown(active_);\n    }\n\n    function disableDeposits(bool active_) external onlyGovernor {\n        depositDisabled = active_;\n    }\n\n    function disableWithdrawals(bool active_) external onlyGovernor {\n        withdrawDisabled = active_;\n    }\n\n    function disableRedeems(bool active_) external onlyGovernor {\n        redeemDisabled = active_;\n    }\n}\n"
    },
    "contracts/interfaces/IsENCTR.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./IERC20.sol\";\n\ninterface IsENCTR is IERC20 {\n    function rebase(uint256 encountrProfit_, uint256 epoch_) external returns (uint256);\n\n    function circulatingSupply() external view returns (uint256);\n\n    function gonsForBalance(uint256 amount) external view returns (uint256);\n\n    function balanceForGons(uint256 gons) external view returns (uint256);\n\n    function index() external view returns (uint256);\n\n    function toG(uint256 amount) external view returns (uint256);\n\n    function fromG(uint256 amount) external view returns (uint256);\n\n    function changeDebt(\n        uint256 amount,\n        address debtor,\n        bool add\n    ) external;\n\n    function debtBalances(address _address) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IYieldDirector.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.7.5;\n\ninterface IYieldDirector {\n    function deposit(uint256 amount_, address recipient_) external;\n\n    function withdraw(uint256 amount_, address recipient_) external;\n\n    function withdrawAll() external;\n\n    function depositsTo(address donor_, address recipient_) external view returns (uint256);\n\n    function getAllDeposits(address donor_) external view returns (address[] memory, uint256[] memory);\n\n    function totalDeposits(address donor_) external view returns (uint256);\n\n    function donatedTo(address donor_, address recipient_) external view returns (uint256);\n\n    function totalDonated(address donor_) external view returns (uint256);\n\n    function redeem() external;\n\n    function redeemableBalance(address recipient_) external view returns (uint256);\n}\n"
    },
    "contracts/libraries/Address.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\n// TODO(zx): replace with OZ implementation.\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    // function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n    //     require(address(this).balance >= value, \"Address: insufficient balance for call\");\n    //     return _functionCallWithValue(target, data, value, errorMessage);\n    // }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 weiValue,\n        string memory errorMessage\n    ) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.3._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.3._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) private pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.5;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as th xe allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "contracts/EncountrAuthority.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./interfaces/IEncountrAuthority.sol\";\n\nimport \"./types/EncountrAccessControlled.sol\";\n\ncontract EncountrAuthority is IEncountrAuthority, EncountrAccessControlled {\n    /* ========== STATE VARIABLES ========== */\n\n    address public override governor;\n\n    address public override guardian;\n\n    address public override policy;\n\n    address public override vault;\n\n    address public newGovernor;\n\n    address public newGuardian;\n\n    address public newPolicy;\n\n    address public newVault;\n\n    /* ========== Constructor ========== */\n\n    constructor(\n        address _governor,\n        address _guardian,\n        address _policy,\n        address _vault\n    ) EncountrAccessControlled(IEncountrAuthority(address(this))) {\n        governor = _governor;\n        emit GovernorPushed(address(0), governor, true);\n        guardian = _guardian;\n        emit GuardianPushed(address(0), guardian, true);\n        policy = _policy;\n        emit PolicyPushed(address(0), policy, true);\n        vault = _vault;\n        emit VaultPushed(address(0), vault, true);\n    }\n\n    /* ========== GOV ONLY ========== */\n\n    function pushGovernor(address _newGovernor, bool _effectiveImmediately) external onlyGovernor {\n        if (_effectiveImmediately) governor = _newGovernor;\n        newGovernor = _newGovernor;\n        emit GovernorPushed(governor, newGovernor, _effectiveImmediately);\n    }\n\n    function pushGuardian(address _newGuardian, bool _effectiveImmediately) external onlyGovernor {\n        if (_effectiveImmediately) guardian = _newGuardian;\n        newGuardian = _newGuardian;\n        emit GuardianPushed(guardian, newGuardian, _effectiveImmediately);\n    }\n\n    function pushPolicy(address _newPolicy, bool _effectiveImmediately) external onlyGovernor {\n        if (_effectiveImmediately) policy = _newPolicy;\n        newPolicy = _newPolicy;\n        emit PolicyPushed(policy, newPolicy, _effectiveImmediately);\n    }\n\n    function pushVault(address _newVault, bool _effectiveImmediately) external onlyGovernor {\n        if (_effectiveImmediately) vault = _newVault;\n        newVault = _newVault;\n        emit VaultPushed(vault, newVault, _effectiveImmediately);\n    }\n\n    /* ========== PENDING ROLE ONLY ========== */\n\n    function pullGovernor() external {\n        require(msg.sender == newGovernor, \"!newGovernor\");\n        emit GovernorPulled(governor, newGovernor);\n        governor = newGovernor;\n    }\n\n    function pullGuardian() external {\n        require(msg.sender == newGuardian, \"!newGuard\");\n        emit GuardianPulled(guardian, newGuardian);\n        guardian = newGuardian;\n    }\n\n    function pullPolicy() external {\n        require(msg.sender == newPolicy, \"!newPolicy\");\n        emit PolicyPulled(policy, newPolicy);\n        policy = newPolicy;\n    }\n\n    function pullVault() external {\n        require(msg.sender == newVault, \"!newVault\");\n        emit VaultPulled(vault, newVault);\n        vault = newVault;\n    }\n}\n"
    },
    "contracts/interfaces/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\ninterface IOwnable {\n    function owner() external view returns (address);\n\n    function renounceManagement() external;\n\n    function pushManagement(address newOwner_) external;\n\n    function pullManagement() external;\n}\n"
    },
    "contracts/types/Ownable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.7.5;\n\nimport \"../interfaces/IOwnable.sol\";\n\nabstract contract Ownable is IOwnable {\n    address internal _owner;\n    address internal _newOwner;\n\n    event OwnershipPushed(address indexed previousOwner, address indexed newOwner);\n    event OwnershipPulled(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        _owner = msg.sender;\n        emit OwnershipPushed(address(0), _owner);\n    }\n\n    function owner() public view override returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceManagement() public virtual override onlyOwner {\n        emit OwnershipPulled(_owner, address(0));\n        _owner = address(0);\n        _newOwner = address(0);\n    }\n\n    function pushManagement(address newOwner_) public virtual override onlyOwner {\n        emit OwnershipPushed(_owner, newOwner_);\n        _newOwner = newOwner_;\n    }\n\n    function pullManagement() public virtual override {\n        require(msg.sender == _newOwner, \"Ownable: must be new owner to pull\");\n        emit OwnershipPulled(_owner, _newOwner);\n        _owner = _newOwner;\n        _newOwner = address(0);\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}